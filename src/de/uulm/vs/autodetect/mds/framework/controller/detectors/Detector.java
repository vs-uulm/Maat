package de.uulm.vs.autodetect.mds.framework.controller.detectors;

import de.uulm.vs.autodetect.mds.framework.controller.ComputeGraphNode;
import de.uulm.vs.autodetect.mds.framework.controller.DetectorWrapper;
import de.uulm.vs.autodetect.mds.framework.model.WorldModelDiff;
import de.uulm.vs.autodetect.mds.framework.model.ipc.DetectionResultIPCMessage;
import de.uulm.vs.autodetect.mds.framework.model.ipc.DetectionTriggerIPCMessage;
import de.uulm.vs.autodetect.mds.framework.model.ipc.IPCException;
import de.uulm.vs.autodetect.mds.framework.model.ipc.IPCMessage;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.lang.reflect.Field;
import java.util.Collection;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;

/**
 * Detectors are modules within the framework that are passed a detection
 * trigger message, which specifies change(s) in the world model since the last
 * version (see {@link DetectionTriggerIPCMessage#getVersion()}). The
 * detector should analyze the change(s) and produce an opinion to represent the
 * accuracy of each change it analyzes. For each analysis, the Detector should
 * generate exactly one {@link DetectionResultIPCMessage}: the
 * {@link DetectorWrapper} will wait for the expected amount of
 * {@link DetectionTriggerIPCMessage}s. A Detector can specify how many
 * responses it generates through
 * {@link #responsesPerMessage(DetectionTriggerIPCMessage)} (which may be
 * different depending on detector state and/or type of message).
 * <p>
 * <p>
 * Implementing a new Detector type involves: - Determining a detection
 * algorithm - Selecting which data types are relevant - Establishing how many
 * results are produced during detection - Implement AbstractDetectorFactory to
 * determine how Detectors should be constructed - Register the
 * AbstractDetectorFactory with {@link DetectorIndex} to enable the detector
 *
 * @author Rens van der Heijden
 */
public abstract class Detector extends ComputeGraphNode {
    private static final Logger l = LogManager.getLogger(Detector.class);

    /**
     * The node where output (i.e., objects returned by implementations of
     * {@link #detect(DetectionTriggerIPCMessage)}) generated by the detector is
     * sent.
     */
    private final ComputeGraphNode output;

    /**
     * The factory that created this detector -- used to identify the set of detectors to which this detector belongs.
     */
    private final AbstractDetectorFactory detectorSpecification;

    /**
     * A simple constructor that enforces some constraints on the subtypes by
     * requiring certain arguments.
     *
     * @param output  The node to which the Detector's output is sent
     * @param factory The unique specification that created this detector.
     */
    protected Detector(ComputeGraphNode output, AbstractDetectorFactory factory) {
        super();
        this.detectorSpecification = factory;
        this.output = output;
    }

    /**
     * Perform a detection on the given message, containing changes to the world
     * model. The Detector guarantees exactly {@link #responsesPerMessage(DetectionTriggerIPCMessage)}
     * messages will be generated (each of type
     * {@link DetectionResultIPCMessage}).
     *
     * @param msg
     */
    public abstract Collection<DetectionResultIPCMessage> detect(DetectionTriggerIPCMessage msg);

    /**
     * Specifies how many responses this detector generates for the given
     * incoming message. Note that there are no guarantees regarding the order
     * of {@link #detect(DetectionTriggerIPCMessage)} and
     * {@link #responsesPerMessage(DetectionTriggerIPCMessage)} calls: the only
     * guarantee is that some time after a
     * {@link #responsesPerMessage(DetectionTriggerIPCMessage)} call, a message
     * will arrive that triggers {@link #consume(IPCMessage)} (which in turn
     * passes the messages to {@link #detect(DetectionTriggerIPCMessage)}).
     *
     * @param msg the message for which detection will be triggered.
     * @return
     */
    public abstract int responsesPerMessage(final DetectionTriggerIPCMessage msg);

    public final AbstractDetectorFactory getDetectorSpecification() {
        return this.detectorSpecification;
    }

    /**
     * Return true iff item fits in the context of the Detector's internal
     * state. This is only important for Detectors of which multiple instances
     * will exist.
     *
     * @param item
     * @return
     */
    public abstract boolean canProcess(WorldModelDiff item);

    /**
     * {@inheritDoc}
     */
    @Override
    public void consume(IPCMessage msg) throws IPCException {
        if (msg instanceof DetectionTriggerIPCMessage)
            for (DetectionResultIPCMessage resultMessage : this.detect((DetectionTriggerIPCMessage) msg))
                this.output.deliverMessage(resultMessage);
        else
            throw new IPCException("invalid IPCMessage at Detector");
    }


    @Override
    protected boolean peek(IPCMessage msg) throws IPCException {
        return true;
    }

    /**
     * Implemented in each detector. Gets a Map and sets the value of the given object to the variable contained in the string
     */
    public void setAttribute(Map<String, Object> detectorParameters, Class<? extends Detector> type) throws NoSuchFieldException, IllegalAccessException {
        for (Map.Entry<String, Object> entry : detectorParameters.entrySet()) {
            String fieldName = entry.getKey();
            Object value = entry.getValue();

            Field f = null;
            try {
                f = type.getDeclaredField(fieldName);
            } catch (NoSuchFieldException e) {
                l.error("Error: Field " + fieldName + " not found!");
                l.error(this);
            }
            if (value instanceof Double) {
                f.setDouble(this, (Double) value);
            } else if (value instanceof Boolean) {
                f.setBoolean(this, (Boolean) value);
            } else if (value instanceof Byte) {
                f.setByte(this, (Byte) value);
            } else if (value instanceof Character) {
                f.setChar(this, (Character) value);
            } else if (value.getClass().equals(f.getClass())) {
                Class clazz = f.getClass();
                Object cast = clazz.cast(value);
                f.set(this, cast);
            }
        }

    }

    /**
     * Return an Object representing the state of this Detector, such that if a new instance is created, on which {@link #setState(Object)} is called, the resulting detection behavior is the same (given the same world model).
     * @return non-null state object, typically as Object[], possibly of size 0.
     */
    public abstract Object getState();

    /**
     * Change the state of this Detector to the given state object. The typical use case for this is to apply the result of a {@link #getState()} call to a new instance to achieve the same detection behavior.
     */
    public abstract void setState(Object state);
}
